from __future__ import annotations

import os
from dataclasses import dataclass
from typing import Any, Dict, Optional

from app.llm.llm_client import (
    LLMClient,
    LLMRequest,
    LLMResult,
    RetryingLLMClient,
    RetryPolicy,
)
from app.llm.transformers_client import TransformersLLMClient, TransformersLLMConfig


# -----------------------------
# Mock client (tests / CI / local dev)
# -----------------------------

class MockLLMClient(LLMClient):
    """
    A deterministic fake LLM client.

    Why we need it:
    - Unit tests should NOT download models or run heavy inference.
    - CI should be stable and fast.
    - Lets you test JSON-parsing + grounding logic safely.

    Behavior:
    - If the prompt requests JSON, we return valid JSON.
    - Otherwise we return a simple echo-like response.
    """

    def __init__(self, model_id: str = "mock-llm-v1"):
        self._model_id = model_id

    @property
    def model_id(self) -> str:
        return self._model_id

    def generate(self, req: LLMRequest) -> LLMResult:
        # Very small heuristic: if prompt mentions JSON, return JSON.
        wants_json = "json" in req.prompt.lower()

        if wants_json:
            text = (
                '{'
                '"explanation":"This is a mock grounded explanation based only on provided inputs.",'
                '"recommendation":"Verify low-confidence fields and re-upload clearer images if needed.",'
                '"warnings":["mock: this output is generated by MockLLMClient"]'
                '}'
            )
        else:
            text = f"[MOCK COMPLETION] Received prompt of length {len(req.prompt)} characters."

        return LLMResult(
            raw_text=text,
            model_id=self._model_id,
            latency_ms=1,
            attempts=1,
            meta={"mock": True, "request_id": req.request_id},
        )


# -----------------------------
# Factory
# -----------------------------

def create_llm_client() -> LLMClient:
    """
    Create an LLM client based on configuration.

    Config sources (in priority order):
    1) app.config.settings (if fields exist)
    2) environment variables
    3) safe defaults

    Env vars supported:
      - LLM_PROVIDER: "mock" | "transformers"
      - LLM_MODEL_ID: HF model id (text-only)
      - LLM_DEVICE: "cpu" | "cuda" | "auto"
      - LLM_TIMEOUT_S: float seconds
      - LLM_RETRY_ATTEMPTS: int
      - LLM_RETRY_BACKOFF_MS: int
    """
    provider = _get_setting_or_env("llm_provider", "LLM_PROVIDER", default="mock").lower()

    # default small model to avoid huge downloads by accident
    model_id = _get_setting_or_env("llm_model_id", "LLM_MODEL_ID", default="distilgpt2")

    device = _get_setting_or_env("llm_device", "LLM_DEVICE", default="auto")
    timeout_s = float(_get_setting_or_env("llm_timeout_s", "LLM_TIMEOUT_S", default="30"))

    max_attempts = int(_get_setting_or_env("llm_retry_attempts", "LLM_RETRY_ATTEMPTS", default="3"))
    backoff_ms = int(_get_setting_or_env("llm_retry_backoff_ms", "LLM_RETRY_BACKOFF_MS", default="250"))

    policy = RetryPolicy(max_attempts=max_attempts, backoff_ms=backoff_ms)

    if provider == "mock":
        base: LLMClient = MockLLMClient(model_id="mock-llm-v1")
        return RetryingLLMClient(base, policy)

    if provider == "transformers":
        cfg = TransformersLLMConfig(
            model_id=model_id,
            device=device,
            timeout_s=timeout_s,
        )
        base = TransformersLLMClient(cfg)
        return RetryingLLMClient(base, policy)

    # Unknown provider: fail safe by falling back to mock (keeps dev experience smooth)
    base = MockLLMClient(model_id="mock-llm-v1")
    return RetryingLLMClient(base, policy)


def _get_setting_or_env(setting_name: str, env_name: str, default: str) -> str:
    """
    Helper: try to read from app.config.settings if attribute exists,
    else fall back to environment variables, else default.
    """
    try:
        from app.config import settings  # local import avoids import cycles at module import time
        if hasattr(settings, setting_name):
            val = getattr(settings, setting_name)
            if val is not None and str(val).strip() != "":
                return str(val)
    except Exception:
        # If settings import fails for any reason, we silently fall back to env/default.
        pass

    return os.getenv(env_name, default)